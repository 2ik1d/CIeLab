<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"> 
<title>CIELab Mobile — pinch zoom ready</title>

<!-- PWA -->
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#ffffff">
<link rel="apple-touch-icon" href="icons/icon-192.png">
<meta name="apple-mobile-web-app-capable" content="yes">

<!-- Plotly -->
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>

<style>
  :root{ --pad:12px; --bg:#f6f7f9; --card:#fff; }
  html,body{ height:100%; margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial; background:var(--bg); -webkit-font-smoothing:antialiased; }
  .app { max-width:820px; margin:0 auto; padding:16px; box-sizing:border-box; }
  h1 { font-size:20px; margin:6px 0 12px; text-align:center; }
  .card { background:var(--card); padding:12px; border-radius:10px; box-shadow:0 1px 4px rgba(0,0,0,0.06); }
  .row { display:flex; gap:8px; margin:8px 0; align-items:center; }
  label { font-size:13px; min-width:34px; }
  input[type=number] { flex:1; padding:8px; font-size:16px; border:1px solid #e3e6ea; border-radius:6px; }
  button { width:100%; padding:12px; margin-top:10px; font-size:17px; border-radius:8px; border:0; background:#0a84ff; color:white; }
  #metrics { margin-top:10px; font-size:14px; background:linear-gradient(180deg,#fff,#fbfdff); padding:10px; border-radius:8px; }
  /* важное: чтобы браузер не перехватывал pinch/drag внутри графиков */
  #plotAB, #plotCL { touch-action: none; -webkit-user-select: none; -webkit-touch-callout: none; }
  /* адаптив */
  @media (max-width:420px){
    .app { padding:8px; }
    h1 { font-size:18px; }
    input[type=number] { font-size:18px; padding:10px; }
    button { font-size:18px; padding:14px; }
  }
</style>
</head>
<body>
<div class="app">
  <h1>CIELab Mobile — pinch & pan</h1>

  <div class="card" aria-label="inputs">
    <div style="font-weight:600">Эталон Reference2</div>
    <div class="row"><label>L*</label><input id="L1" type="number" value="55" step="0.1"></div>
    <div class="row"><label>a*</label><input id="a1" type="number" value="20" step="0.1"></div>
    <div class="row"><label>b*</label><input id="b1" type="number" value="30" step="0.1"></div>

    <div style="height:8px"></div>

    <div style="font-weight:600">Образец Sample</div>
    <div class="row"><label>L*</label><input id="L2" type="number" value="53.5" step="0.1"></div>
    <div class="row"><label>a*</label><input id="a2" type="number" value="18" step="0.1"></div>
    <div class="row"><label>b*</label><input id="b2" type="number" value="25" step="0.1"></div>

    <button id="buildBtn">Построить</button>
  </div>

  <div id="metrics" class="card" style="margin-top:12px;"></div>

  <!-- графики -->
  <div id="plotAB" class="card" style="margin-top:12px; height:420px;"></div>
  <div id="plotCL" class="card" style="margin-top:12px; height:300px;"></div>
</div>

<script>
/* =========================
   Utilities: Lab <-> RGB
   ========================= */
function labToXYZ(L,a,b){
  const fy = (L + 16)/116;
  const fx = fy + a/500;
  const fz = fy - b/200;
  function fInv(t){ const delta = 6/29; return t>delta ? t*t*t : 3*delta*delta*(t - 4/29); }
  const xr = fInv(fx), yr = fInv(fy), zr = fInv(fz);
  return [xr*95.047, yr*100.0, zr*108.883];
}
function xyzToSRGB(X,Y,Z){
  let x = X/100, y = Y/100, z = Z/100;
  let r =  x*3.2406 + y*(-1.5372) + z*(-0.4986);
  let g =  x*(-0.9689) + y*1.8758 + z*0.0415;
  let b =  x*0.0557 + y*(-0.2040) + z*1.0570;
  function comp(c){ return c<=0.0031308 ? 12.92*c : 1.055*Math.pow(c,1/2.4)-0.055; }
  r = comp(r); g = comp(g); b = comp(b);
  return [Math.min(Math.max(0,r),1), Math.min(Math.max(0,g),1), Math.min(Math.max(0,b),1)];
}
function labToSRGB(lab){ return xyzToSRGB(...labToXYZ(lab)); }

/* =========================
   DeltaE76 & helpers
   ========================= */
function deltaE76(l1,l2){ return Math.hypot(l1[0]-l2[0], l1[1]-l2[1], l1[2]-l2[2]); }
function chroma(lab){ return Math.hypot(lab[1], lab[2]); }
function hueDeg(lab){ let ang = Math.atan2(lab[2], lab[1]) * 180/Math.PI; return ang<0?ang+360:ang; }

/* =========================
   Smooth AB background (canvas -> dataURL)
   ========================= */
function makeABCanvas(size, L_for_bg=50){
  // size: canvas size in px. Use moderate size for performance on phones (e.g. 256 or 320)
  const c = document.createElement('canvas'); c.width = size; c.height = size;
  const ctx = c.getContext('2d');
  const img = ctx.createImageData(size, size);
  for(let j=0;j<size;j++){
    for(let i=0;i<size;i++){
      // map i->a in [-100,100], j->b in [100,-100] (so y up is +b)
      const a = (i/ (size-1))*200 - 100;
      const b = ((size-1-j)/ (size-1))*200 - 100;
      const rgb = labToSRGB([L_for_bg, a, b]).map(x => Math.round(x*255));
      const idx = (j*size + i)*4;
      img.data[idx]   = rgb[0];
      img.data[idx+1] = rgb[1];
      img.data[idx+2] = rgb[2];
      img.data[idx+3] = 255;
    }
  }
  ctx.putImageData(img, 0, 0);
  return c.toDataURL();
}

/* =========================
   Plot building
   ========================= */
const plotAB = document.getElementById('plotAB');
const plotCL = document.getElementById('plotCL');
const buildBtn = document.getElementById('buildBtn');
const metricsBox = document.getElementById('metrics');

function readLabs(){
  return [
    [parseFloat(document.getElementById('L1').value || 0),
     parseFloat(document.getElementById('a1').value || 0),
     parseFloat(document.getElementById('b1').value || 0)],
    [parseFloat(document.getElementById('L2').value || 0),
     parseFloat(document.getElementById('a2').value || 0),
     parseFloat(document.getElementById('b2').value || 0)]
  ];
}

async function build(){
  const [labRef, labSamp] = readLabs();
  const dE = deltaE76(labRef, labSamp);
  const Cref = chroma(labRef).toFixed(2), Csamp = chroma(labSamp).toFixed(2);
  const href = hueDeg(labRef).toFixed(1), hs = hueDeg(labSamp).toFixed(1);

  metricsBox.innerHTML = `<strong>ΔE76:</strong> ${dE.toFixed(3)} &nbsp; | &nbsp;
                          <strong>Ref:</strong> C=${Cref}, h=${href}° &nbsp; | &nbsp;
                          <strong>Sample:</strong> C=${Csamp}, h=${hs}°`;

  // generate background image (keep size moderate for phones for perf)
  const bgDataUrl = makeABCanvas(320, 55); // L ~ 55 gives representative hues

  // points and vector
  const refTrace = { x:[labRef[1]], y:[labRef[2]], mode:'markers', name:'Reference', marker:{size:16, color: `rgba(0,0,0,0.85)` , symbol:'circle-open'} };
  const sampTrace = { x:[labSamp[1]], y:[labSamp[2]], mode:'markers', name:'Sample', marker:{size:16, color: `rgba(0,0,0,0.85)`, symbol:'x'} };
  const vecTrace = { x:[labRef[1], labSamp[1]], y:[labRef[2], labSamp[2]], mode:'lines', name:'Vector', line:{dash:'dot', width:2, color:'#333'} };

  const layoutAB = {
    title: { text:'CIELab a* vs b*', x:0.02, xanchor:'left' },
    xaxis: { title:'a*', range:[-105,105], zeroline:false, scaleratio:1 },
    yaxis: { title:'b*', range:[-105,105], zeroline:false },
    images: [{ source:bgDataUrl, xref:'x', yref:'y', x:-100, y:100, sizex:200, sizey:200, sizing:'stretch', layer:'below' }],
    margin:{l:50,r:10,t:50,b:50},
    dragmode:'pan'
  };

  // config: enable scrollZoom (pinch as wheel), show modebar so reset is available, responsive
  const configAB = { scrollZoom:true, displayModeBar:true, responsive:true, staticPlot:false };

  // create plot (use Plotly.react to avoid flicker)
  await Plotly.react(plotAB, [refTrace, sampTrace, vecTrace], layoutAB, configAB);

  // ensure the plot element doesn't allow page zoom: touch-action none set in CSS
  // Now Chroma vs L*
  const clTrace = {
    x: [Cref, Csamp].map(Number),
    y: [labRef[0], labSamp[0]],
    mode: 'markers+text',
    text: ['Ref','Sample'],
    textposition: 'right',
    marker: { size:14, color:['#111','#111'] }
  };
  const layoutCL = { title:'Chroma vs Lightness (L*)', xaxis:{title:'Chroma'}, yaxis:{title:'L*', range:[0,100]}, margin:{l:50,r:10,t:40,b:40} };
  const configCL = { scrollZoom:true, displayModeBar:true, responsive:true, staticPlot:false };
  await Plotly.react(plotCL, [clTrace], layoutCL, configCL);

  // set initial zoom hint for mobile: small overlay? (skip to keep UI minimal)
}

/* attach */
buildBtn.addEventListener('click', build);

/* build on first load */
window.addEventListener('load', build);

/* register service worker (optional) */
if('serviceWorker' in navigator){
  navigator.serviceWorker.register('service-worker.js').then(()=>console.log('sw registered')).catch(e=>console.log('sw reg failed', e));
}

/* Prevent accidental page pinch/zoom while interacting inside graphs:
   touch-action: none (CSS) is the primary. But on some browsers also prevent default for two-finger gestures.
   We attach passive:false listeners on plot containers to ensure JS receives gesture events.
*/
function allowPlotTouchInteraction(el){
  if(!el) return;
  el.addEventListener('touchstart', function(e){ /* no-op, but keep default prevented if needed */ }, {passive:false});
  el.addEventListener('touchmove', function(e){ /* no-op */ }, {passive:false});
}
allowPlotTouchInteraction(plotAB);
allowPlotTouchInteraction(plotCL);
</script>
</body>
</html>
